---
layout: default
title: How does it work?
nav_order: 4
---
### Logical Architecture

![](/images/logical_architecture.jpg)

Qontract leverages evolutionary architecture principles and is extensible by design. The blue boxes within the dotted line make up the core.
We are then able to add support for Web APIs, Messaging Platforms, Testing Frameworks, etc. as drop add on capabilities.

* **Gherkin Lexer** is central to the working of Qontract. It translates Gherkin to executable Scenarios which can either behave as stub / mock responses or tests for consumers and providers respectively.
* **Consumer Side**
  * Stub Server (Command Line) - When Consumer invokes the stub it, leverages the scenarios generated by Lexer to generate responses
  * Mock Server (Programmatic) - Similar to Stub Server. However mock, as the name suggests, verifies expectations that are set on it
* **Provider Side**
  * Contract Test Command Line - Runs the executable scenarios as tests against a provider instance
  * Contract Test JUnit Support - Same as command line, however it runs the executable scenarios through JUnit Dynamic Tests which your IDE will be able to display like regular JUnit Test Results
* **Contract vs Contract** is a unique capability where we can compare two contract signatures for compatibility without having to implement either contract. This component takes another version of the contract as an input to compare with the initial contract.

